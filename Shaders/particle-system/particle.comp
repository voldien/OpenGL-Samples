#version 460 core
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 32, local_size_y = 1) in;

struct particle_t {
	vec3 position;
	float time;
	vec4 velocity;
};

struct particle_setting {
	float speed;
	float lifetime;
	float gravity;
};

/*	*/
layout(std430, binding = 1) readonly buffer ReadBuffer { particle_t particle[]; }
readBuffer;
/*	*/
layout(std430, binding = 2) writeonly buffer WriteBuffer { particle_t particle[]; }
writeBuffer;

layout(binding = 0) uniform UniformBufferBlock {
	mat4 model;
	mat4 view;
	mat4 proj;
	mat4 modelView;
	mat4 modelViewProjection;

	particle_setting setting;

	/*	*/
	float deltaTime;
}
ubo;

float rand(vec2 co) {
	highp float a = 12.9898;
	highp float b = 78.233;
	highp float c = 43758.5453;
	highp float dt = dot(co.xy, vec2(a, b));
	highp float sn = mod(dt, 3.14);
	return fract(sin(sn) * c);
}

void main() {

	uint index = gl_GlobalInvocationID.x;

	/*	*/
	vec3 position = readBuffer.particle[index].position;
	float time = readBuffer.particle[index].time;
	vec4 vel = readBuffer.particle[index].velocity;

	vec3 force_impulse = vec3(rand(gl_GlobalInvocationID.xy));

	float k_v = 1.5;

	const float deltaTime = ubo.setting.speed * ubo.deltaTime;

	/*	*/
	vec3 v = vel.xyz + (force_impulse)*k_v * deltaTime;
	vec3 nextPosition = position + v * deltaTime;

	/*	Reset particle when expired.	*/
	time -= deltaTime;
	if (time <= 0) {
		/*	*/
		nextPosition = -nextPosition + rand(nextPosition.xy + vec2(index, index)) * 20.0 -
					   rand(nextPosition.yz + vec2(index, index)) * 20.0;
		v.xyz *= rand(nextPosition.yz + vec2(index, index)) * 0.1;
		/*	*/
		time = ubo.setting.lifetime;
	}

	/*	Update particle.	*/
	writeBuffer.particle[index].time = time;
	writeBuffer.particle[index].position = nextPosition;
	writeBuffer.particle[index].velocity = vec4(v, vel.w);
}