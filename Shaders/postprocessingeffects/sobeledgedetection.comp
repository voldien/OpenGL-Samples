#version 460 core
#extension GL_ARB_derivative_control : enable
#extension GL_ARB_enhanced_layouts : enable
#extension GL_ARB_shader_image_load_store : enable
#extension GL_ARB_explicit_attrib_location : enable

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(set = 0, binding = 1, rgba16) uniform coherent image2D texture0;

void main() {

	/*	*/
	if (any(greaterThan(gl_GlobalInvocationID.xy, imageSize(texture0)))) {
		return;
	}
	
	// Compute sample coordinate.
	ivec2 TexDiff = ivec2(1, 1);
	ivec2 sampleTexCoord = ivec2(gl_GlobalInvocationID.xy);

	// TODO add recompute of the sample kernel coordinates.
	const ivec2 lb = ivec2(-1 * TexDiff.x, -1 * TexDiff.y);
	const vec4 p00 = imageLoad(texture0, sampleTexCoord + lb);
	const ivec2 b = ivec2(0.0 * TexDiff.x, -1 * TexDiff.y);
	const vec4 p10 = imageLoad(texture0, sampleTexCoord + b);
	const ivec2 rb = ivec2(1 * TexDiff.x, -1 * TexDiff.y);
	const vec4 p20 = imageLoad(texture0, sampleTexCoord + rb);

	const ivec2 l = ivec2(-1 * TexDiff.x, 0.0 * TexDiff.y);
	const vec4 p01 = imageLoad(texture0, sampleTexCoord + l);
	const ivec2 r = ivec2(1 * TexDiff.x, 0.0 * TexDiff.y);
	const vec4 p21 = imageLoad(texture0, sampleTexCoord + r);

	const ivec2 lt = ivec2(-1 * TexDiff.x, 1 * TexDiff.y);
	const vec4 p02 = imageLoad(texture0, sampleTexCoord + lt);
	const ivec2 t = ivec2(-1 * TexDiff.x, 1 * TexDiff.y);
	const vec4 p12 = imageLoad(texture0, sampleTexCoord + t);
	const ivec2 rt = ivec2(1 * TexDiff.x, 1 * TexDiff.y);
	const vec4 p22 = imageLoad(texture0, sampleTexCoord + rt);

	/* Compute Matrix X and Y.	*/
	const vec3 gx = -p00.xyz + p20.xyz + 2.0 * (p21.xyz - p01.xyz) - p02.xyz + p22.xyz;
	const vec3 gy = -p00.xyz - p20.xyz + 2.0 * (p12.xyz - p10.xyz) + p02.xyz + p22.xyz;

	/* Compute the final.	*/
	const vec3 g = sqrt(gx * gx + gy * gy);

	/*	*/
	memoryBarrierImage();

	imageStore(texture0, sampleTexCoord, vec4(g.rgb, 1));
}