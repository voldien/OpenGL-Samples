#version 460 core
#extension GL_ARB_derivative_control : enable
#extension GL_ARB_enhanced_layouts : enable
#extension GL_ARB_shader_image_load_store : enable
#extension GL_ARB_explicit_attrib_location : enable

precision highp float;
precision mediump int;

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba16) uniform
	restrict readonly image2D ColorTexture; // TODO: change to sampler2D to make use of filtering
layout(set = 0, binding = 1, rgba16f) uniform coherent writeonly image2D TargetTexture;

layout(set = 0, binding = 0, std140) uniform UniformSettingsBlock { float radius; }
settings;

void main() {

	/*	*/
	if (any(greaterThan(gl_GlobalInvocationID.xy, imageSize(ColorTexture)))) {
		return;
	}

	// Compute sample coordinate.
	ivec2 TexDiff = ivec2(1, 1);
	ivec2 sampleTexCoord = ivec2(gl_GlobalInvocationID.xy);

	// TODO add recompute of the sample kernel coordinates.
	const ivec2 lb = ivec2(-1 * TexDiff.x, -1 * TexDiff.y);
	const vec4 p00 = imageLoad(ColorTexture, sampleTexCoord + lb);
	const ivec2 b = ivec2(0.0 * TexDiff.x, -1 * TexDiff.y);
	const vec4 p10 = imageLoad(ColorTexture, sampleTexCoord + b);
	const ivec2 rb = ivec2(1 * TexDiff.x, -1 * TexDiff.y);
	const vec4 p20 = imageLoad(ColorTexture, sampleTexCoord + rb);

	const ivec2 l = ivec2(-1 * TexDiff.x, 0.0 * TexDiff.y);
	const vec4 p01 = imageLoad(ColorTexture, sampleTexCoord + l);
	const ivec2 r = ivec2(1 * TexDiff.x, 0.0 * TexDiff.y);
	const vec4 p21 = imageLoad(ColorTexture, sampleTexCoord + r);

	const ivec2 lt = ivec2(-1 * TexDiff.x, 1 * TexDiff.y);
	const vec4 p02 = imageLoad(ColorTexture, sampleTexCoord + lt);
	const ivec2 t = ivec2(-1 * TexDiff.x, 1 * TexDiff.y);
	const vec4 p12 = imageLoad(ColorTexture, sampleTexCoord + t);
	const ivec2 rt = ivec2(1 * TexDiff.x, 1 * TexDiff.y);
	const vec4 p22 = imageLoad(ColorTexture, sampleTexCoord + rt);

	/* Compute Matrix X and Y.	*/
	const vec3 gx = -p00.xyz + p20.xyz + 2.0 * (p21.xyz - p01.xyz) - p02.xyz + p22.xyz;
	const vec3 gy = -p00.xyz - p20.xyz + 2.0 * (p12.xyz - p10.xyz) + p02.xyz + p22.xyz;

	/* Compute the final.	*/
	const vec3 edgeColor = sqrt(gx * gx + gy * gy);

	// float prop = step(_ThresHold, length(round(g.rgb)));
	// float4 edge = lerp(color.rgba, _Color.rgba, prop);
	// g = edge.rgb;
	// g = 1 - (1 - color.rgb) * (1 - g.rgb * _Color * length(g));

	/*	*/

	imageStore(TargetTexture, sampleTexCoord, vec4(edgeColor.rgb, 1));
}