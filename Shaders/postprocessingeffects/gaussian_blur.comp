#version 460 core
#extension GL_ARB_enhanced_layouts : enable
#extension GL_ARB_shader_image_load_store : enable
#extension GL_ARB_explicit_attrib_location : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_16bit_storage : require
#extension GL_ARB_shading_language_include : enable
#extension GL_GOOGLE_include_directive : enable

precision mediump float;
precision mediump int;

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 1, rgba16f) uniform image2D texture0;

layout(push_constant) uniform Settings {
	layout(offset = 0) float variance;
	layout(offset = 4) float mean;
	layout(offset = 8) float radius;
	layout(offset = 12) int samples;
}
settings;

#include "postprocessing_base.glsl"
layout(constant_id = 16) const int MAX_SAMPLES = 10;

// const T exp_inverse = (static_cast<T>(1.0) / (static_cast<T>(2.0) * standard_deviation * standard_deviation));
// const T sqr_2_pi_inverse = 1.0 / (standard_deviation * static_cast<T>(std::sqrt(2 * Math::PI)));
// const T exp_num_sqrt = (i - theta + offset);

// const T exponent = exp_inverse * -(exp_num_sqrt * exp_num_sqrt);
// const T value = sqr_2_pi_inverse * std::exp(exponent);

float getGuas2D(const in float x, const in float y, const in float variance) {
	return (1.0 / (2 * PI * variance * variance)) * pow(E_CONSTANT, -0.5 * ((x * x) + (y * y)) / (variance * variance));
}

vec4 blurHorizontal(const in float radius, const in float variance, const in int samples) {
	int y;

	const ivec2 resolution = imageSize(texture0);

	const ivec2 TexCoord = ivec2(gl_GlobalInvocationID.xy);

	const int start = clamp(-((samples - 1) / 2), -MAX_SAMPLES, -1);
	const int end = clamp(((samples - 1) / 2), 1, MAX_SAMPLES);

	vec4 color1 = vec4(0.0);
	float total = EPSILON;

	for (y = start; y <= end; y++) {

		const ivec2 uv = TexCoord + ivec2(vec2(0, y) * radius);

		const float guas = getGuas2D(0, y, variance);

		color1 += imageLoad(texture0, uv).rgba * vec4(guas.xxx, 1.0);
		total += guas;
	}

	return color1 / total;
}

vec4 blurVertical(const in float radius, const in float variance, const in int samples) {
	int x;

	const ivec2 resolution = imageSize(texture0);

	const ivec2 TexCoord = ivec2(gl_GlobalInvocationID.xy);

	const int start = clamp(-((samples - 1) / 2), -MAX_SAMPLES, -1);
	const int end = clamp(((samples - 1) / 2), 1, MAX_SAMPLES);

	vec4 color1 = vec4(0.0);
	float total = EPSILON;

	for (x = start; x <= end; x++) {
		const ivec2 uv = TexCoord + ivec2(vec2(x, 0) * radius);
		const float guas = getGuas2D(x, 0, variance);

		color1 += imageLoad(texture0, uv).rgba * vec4(vec3(guas), 1.0);
		total += guas;
	}

	// Normalize color.
	return color1 / total;
}

void main() {

	/*	*/
	if (any(greaterThan(gl_GlobalInvocationID.xy, imageSize(texture0)))) {
		return;
	}

	const ivec2 TexCoord = ivec2(gl_GlobalInvocationID.xy);

	/*	*/
	{

		const vec4 verticalBlur = blurVertical(settings.radius, settings.variance, settings.samples);

		memoryBarrierImage();

		imageStore(texture0, TexCoord, vec4(verticalBlur.rgb, 1.0));

		memoryBarrierImage();
	}

	/*	*/
	{

		const vec4 blurHorizontalBlur = blurHorizontal(settings.radius, settings.variance, settings.samples);

		memoryBarrierImage();

		imageStore(texture0, TexCoord, vec4(blurHorizontalBlur.rgb, 1.0));
	}
}