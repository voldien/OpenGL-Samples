#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_compute_shader : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, r8ui) uniform readonly uimage2D previousCellsTexture;

layout(binding = 1, r8ui) uniform writeonly uimage2D currentCellsTexture;

layout(binding = 2, rgba8) uniform writeonly image2D renderTexture;

const int GOFLUT[10] = {0, 0, 1, 1, 0, 0, 0, 0, 0, 0};
const int GOFLUTDEAD[10] = {0, 0, 0, 1, 0, 0, 0, 0, 0, 0};

const int mat[10] = {1, 1, 1, 1, 0, 1, 1, 1, 1, 0};
const vec3 color[10] = {vec3(0, 0, 0),		 vec3(0, 1, 0),	  vec3(1, 0, 0),   vec3(0, 0, 1), vec3(0, 1, 1),
						vec3(0.4, 0.3, 0.4), vec3(0.1, 0, 1), vec3(0.1, 1, 0), vec3(0, 0, 0), vec3(0, 0, 0)};

void main() {

	/*	Get pixel coordinate.	*/
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

	/*	Get current cell state, alive or dead.	*/
	uint cell = min(imageLoad(previousCellsTexture, pixel_coords).r, 1);

	uint sum = 0;

	/*	Check Each cell on the kernel. sums the number of alive cells.	*/
	for (int y = -1; y <= 1; y++) {
		for (int x = -1; x <= 1; x++) {

			const uint index = (x + 1) + (y + 1) * 3;
			ivec2 offsetCordinate = (pixel_coords + ivec2(x, y)) % imageSize(previousCellsTexture);

			/*	*/
			sum += min(imageLoad(previousCellsTexture, offsetCordinate).r, 1) * mat[index];
		}
	}

	/*	Compute if cell is alive.	*/
	uint IsDeadCell = uint(step(float(cell), 0.5));

	/*	Sum of cell alive state and dead cell state.	*/
	uint result = (GOFLUT[sum] * cell) + GOFLUTDEAD[sum] * IsDeadCell;

	/*	Update the current cell state.	*/
	imageStore(currentCellsTexture, pixel_coords, uvec4(result));
	/*	Update the render texture.	*/
	imageStore(renderTexture, pixel_coords, vec4(color[sum], 1));
}
