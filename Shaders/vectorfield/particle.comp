#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_compute_shader : enable

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

struct particle_t {
	vec3 position;
	float time;
	vec4 velocity;
};

struct particle_setting {
	uvec3 particleBox;
	float speed;
	float lifetime;
	float gravity;
	float strength;
	float density;
};

/**
 * Motion pointer.
 */
struct motion_t {
	vec2 pos; /*  Position in pixel space.    */
	vec2 velocity /*  direction and magnitude of mouse movement.  */;
	float radius; /*  Radius of incluense, also the pressure of input.    */
};

layout(binding = 0) uniform UniformBufferBlock {
	mat4 model;
	mat4 view;
	mat4 proj;
	mat4 modelView;
	mat4 modelViewProjection;

	/*	*/
	float deltaTime;

	particle_setting setting;
	motion_t motion;

	vec4 ambientColor;
	vec4 color;
}
ubo;

/*	*/
layout(std430, binding = 3) readonly buffer VectorField { vec3 field[]; }
vectorfield;

/*	*/
layout(std430, binding = 1) readonly buffer ReadBuffer { particle_t particle[]; }
readBuffer;
/*	*/
layout(std430, binding = 2) writeonly buffer WriteBuffer { particle_t particle[]; }
writeBuffer;

/**
 * Compute force influence from vector field.
 */
vec3 computeInfluence(const vec3 position) {

	const int infl = 2;
	const float amplitude = 1.0;
	const float virtualGridScale = 10.0;

	const uvec3 vectorBox = ubo.setting.particleBox;

	/*	Get position and position index.	*/
	const vec3 flopos = floor(position);
	const uvec3 ij = min(uvec3(flopos), vectorBox - (0, 0));

	/*	Compute total force.	*/
	vec3 force = vec3(0, 0, 0);
	for (uint y = 0; y < infl; y++) {

		/*	Prefech vector field vector forces.	*/
		// const int memOffset = (ij.y * vectorBox.x);
		// prefetch(&vector[memOffset], infl);
		for (uint x = 0; x < infl; x++) {

			/*	Compute position and memory location.	*/
			const uvec3 vpos = ij + uvec3(x, y, 0);
			const vec3 fvpos = flopos + vec3(x, y, 0);

			/*	Fetch vector force.	*/
			const uint index = (vpos.y * vectorBox.x) + vpos.x;
			const vec3 vecforce = vectorfield.field[0];

			/*	Compute influence force.	*/
			const float dist = distance(fvpos, position);
			const float distSquare = pow(dist, 2.0) * virtualGridScale;
			const float invDist = 1.0 / (distSquare);

			/*	Sum Additional force.	*/
			force += (vecforce * invDist) * amplitude;
		}
	}
	return force;
}

/**
 * Compute motion influence from motion pointer.
 */
vec2 computeMotionInfluence(vec4 particle) {
	/*	*/
	float dist = distance(particle.xy, ubo.motion.pos);
	float infl = 1.0; // select(dist, ubo.motion.radius, isgreater(ubo.motion.radius, dist));

	return (1.0 / infl) * ubo.motion.velocity;
}

/**
 * Perform particle simulation with vector field.
 */
void main() {

	/*	Bounding Box of the simluation.	*/
	const vec3 max = vec3(ubo.setting.particleBox.x, ubo.setting.particleBox.y, ubo.setting.particleBox.z);
	const vec3 min = vec3(0, 0, 0);

	/*	Iterator.	*/
	uvec3 index = gl_GlobalInvocationID.xyz;

	const uint pindex = index.x * index.y + index.z;

	/*  Get particle.   */
	vec3 position = readBuffer.particle[pindex].position;
	vec3 velocity = readBuffer.particle[pindex].velocity.xyz;
	const float invMass = readBuffer.particle[pindex].velocity.w;

	//
	///*  Get vector of incluense. - Bilinear   */
	const vec3 forceInf = computeInfluence(position);
	const vec3 motionInf = vec3(0); // computeMotionInfluence(position, &motion);

	/*  Compute total force.  */
	vec3 force = (velocity + forceInf + motionInf);

	/*  Add force to particle position. */
	velocity = force * invMass;
	/*	Update the position.	*/
	position = position + velocity * ubo.deltaTime;
	//
	///*	Final position update.	*/
	position.xyz = clamp(position.xyz, min, max);

	writeBuffer.particle[pindex].position = position;
	writeBuffer.particle[pindex].velocity = vec4(velocity, 1);
}
