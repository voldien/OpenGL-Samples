#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 2, local_size_y = 2, local_size_z = 2) in;

struct particle_t {
	vec3 position;
	float time;
	vec4 velocity;
};

struct particle_setting {
	float speed;
	float lifetime;

	float gravity;
	float deltatime;
};

/**
 * Motion pointer.
 */
struct motion_t {
	vec2 pos; /*  Position in pixel space.    */
	vec2 velocity /*  direction and magnitude of mouse movement.  */;
	float radius; /*  Radius of incluense, also the pressure of input.    */
};

layout(binding = 0) uniform UniformBufferBlock {
	mat4 model;
	mat4 view;
	mat4 proj;
	mat4 modelView;
	mat4 modelViewProjection;

	/*	*/
	float deltaTime;
	vec3 particleBox;
	float density;

	particle_setting setting;
	motion_t motion;
}
ubo;

/*	*/
layout(std430, binding = 2) readonly buffer VectorField { vec3 particle[]; }
vectorfield;

/*	*/
layout(std430, binding = 1) readonly buffer ReadBuffer { particle_t particle[]; }
readBuffer;
/*	*/
layout(std430, binding = 2) writeonly buffer WriteBuffer { particle_t particle[]; }
writeBuffer;

/**
 * Compute force influence from vector field.
 */
vec2 computeInfluence(const vec2 position, const ivec2 vectorBox, const vec2 vector) {

	const int infl = 2;
	const float amplitude = 1.0;
	const float virtualGridScale = 10.0;

	/*	Get position and position index.	*/
	const vec2 flopos = floor(position);
	const ivec2 ij = min(ivec2(flopos), vectorBox - (0, 0));

	/*	Compute total force.	*/
	vec2 force = vec2(0.0, 0.0);
	for (int y = 0; y < infl; y++) {

		/*	Prefech vector field vector forces.	*/
		const int memOffset = (ij.y * vectorBox.x);
		// prefetch(&vector[memOffset], infl);
		for (int x = 0; x < infl; x++) {

			/*	Compute position and memory location.	*/
			const ivec2 vpos = ij + ivec2(x, y);
			const vec2 fvpos = flopos + vec2(x, y);

			/*	Fetch vector force.	*/
			const int index = (vpos.y * vectorBox.x) + vpos.x;
			const vec2 vecforce = vectorfield.particle[index].xy;

			/*	Compute influence force.	*/
			const float dist = distance(fvpos, position);
			const float distSquare = pow(dist, 2.0) * virtualGridScale;
			const float invDist = 1.0 / (distSquare);

			/*	Sum Additional force.	*/
			force += (vecforce * invDist) * amplitude;
		}
	}
	return force;
}

/**
 * Compute motion influence from motion pointer.
 */
vec2 computeMotionInfluence(vec4 particle) {
	/*	*/
	float dist = distance(particle.xy, ubo.motion.pos);
	float infl = 1.0; // select(dist, ubo.motion.radius, isgreater(ubo.motion.radius, dist));

	return (1.0 / infl) * ubo.motion.velocity;
}

/**
 * Perform particle simulation with vector field.
 */
void main() {

	/*	Particle mass.	*/
	const float mass = 1.0;
	const float invMass = 1.0 / mass;

	/*	Bounding Box of the simluation.	*/
	const vec2 max = vec2(ubo.particleBox.x, ubo.particleBox.y);
	const vec2 min = vec2(0.0, 0.0);

	/*	Iterator.	*/
	uvec3 index = gl_GlobalInvocationID.xyz;

	uint gx = index.x;
	uint gy = index.y;

	/*	*/
	uint gw = gl_WorkGroupSize.x;
	uint gh = gl_WorkGroupSize.x;

	/*	Private group size.	*/
	uint nhw = int(2 * ubo.density);
	uint nlw = int(2 * ubo.density);

	/*  Iterate through each particle in block.  */
	for (int y = 0; y < nhw; y++) {
		/*	Cache particles.	*/
		const uint prow = ((nhw * gy) * (gw * nhw)) + (y * gw * nlw) + (gx * nlw);

		/*	*/
		for (int x = 0; x < nlw; x++) {
			uint pindex = prow + x;

			/*  Get particle.   */
			vec3 position = readBuffer.particle[pindex].position;
			vec3 velocity = readBuffer.particle[pindex].velocity.xyz;

			//
			///*  Get vector of incluense. - Bilinear   */
			const vec3 forceInf = vec3(0);	// computeInfluence(position, ubo.vectorBox, ubo.vectorfield);
			const vec3 motionInf = vec3(0); // computeMotionInfluence(position, &motion);

			/*  Compute total force.  */
			vec3 force = (velocity + forceInf + motionInf);

			/*  Add force to particle position. */
			velocity = force * invMass;
			/*	Update the position.	*/
			position = position + velocity * ubo.setting.deltatime;
			//
			///*	Final position update.	*/
			// position.xy = clamp(position.xy, min, max);

			writeBuffer.particle[pindex].position = position;
			writeBuffer.particle[pindex].velocity = vec4(velocity, 1);
		}
	}
}
